# 前端事件分组优化完整方案

## 📋 问题分析

### 当前架构问题
1. **事件处理重复**：workspace页面和unified-store都处理相同的SSE事件
2. **消息模型错误**：每个SSE事件都转换为独立Message，缺少事件分组概念
3. **OutputStream显示问题**：
   - 滚动重复触发
   - 时间排序错误（字符串比较而非时间比较）
   - 缺少流式显示（同一event的多个chunk分离显示）

### 技术事实确认
- **后端SSE事件**：13种类型（navigation, metadata, node_start, node_complete, plan_generated, search_results, agent_output, message_chunk, artifact, progress, interrupt, complete, error）
- **前端处理层次**：fetch-stream.ts → research-stream.ts → workspace/page.tsx → unified-store.ts
- **当前消息模型**：每个SSE事件 = 一个Message对象
- **OutputStream期望**：按事件类型分组，同一事件的多个chunk合并显示

## 🎯 优化方案

### 核心设计原则
1. **事件分组**：相同类型的事件应该分组显示
2. **流式合并**：message_chunk事件应该按chunk_id合并
3. **时序准确**：使用真实时间戳排序
4. **职责分离**：避免重复的事件处理逻辑

### 方案1：Event-Based Message Model（推荐）

#### 数据结构设计
```typescript
// 扩展Message类型，支持事件分组
interface EventMessage extends Message {
  eventType: SSEEventType;           // 事件类型
  eventId: string;                   // 事件唯一ID
  chunks: MessageChunk[];            // 事件包含的所有chunk
  isEventComplete: boolean;          // 事件是否完成
  eventMetadata: {
    startTime: string;               // 事件开始时间
    endTime?: string;                // 事件结束时间
    nodeContext?: string;            // 节点上下文
    [key: string]: any;
  };
}

interface MessageChunk {
  chunkId: string;
  content: string;
  sequence: number;
  timestamp: string;
  isFinal: boolean;
}
```

#### 事件分组逻辑
```typescript
// 事件分组策略
const groupEvents = (sseEvents: SSEEvent[]): EventMessage[] => {
  const eventGroups = new Map<string, EventMessage>();
  
  for (const event of sseEvents) {
    const eventId = generateEventId(event);
    
    if (event.type === 'message_chunk') {
      // message_chunk按chunk_id分组
      const chunkEventId = event.data.chunk_id;
      if (!eventGroups.has(chunkEventId)) {
        eventGroups.set(chunkEventId, createEventMessage(event));
      }
      addChunkToEvent(eventGroups.get(chunkEventId)!, event.data);
    } else {
      // 其他事件类型独立处理
      eventGroups.set(eventId, createEventMessage(event));
    }
  }
  
  return Array.from(eventGroups.values());
};
```

### 方案2：Hybrid Message Model（备选）

#### 保持现有Message接口，添加事件分组层
```typescript
// 在OutputStream组件层面进行分组
interface EventGroup {
  eventType: SSEEventType;
  eventId: string;
  messages: Message[];              // 属于该事件的所有消息
  startTime: string;
  endTime?: string;
  isComplete: boolean;
}

// OutputStream使用EventGroup而非直接使用Message
const groupMessagesIntoEvents = (messages: Message[]): EventGroup[] => {
  // 按事件类型和时间窗口分组消息
};
```

## 🔧 实施计划

### 阶段1：修复OutputStream滚动和排序问题
- **目标**：解决重复刷新和时间排序错误
- **修改范围**：仅`output-stream.tsx`
- **技术方案**：
  1. 修复useEffect依赖，避免重复触发
  2. 使用Date对象进行时间排序
  3. 优化滚动逻辑

### 阶段2：实现事件分组显示
- **目标**：同一事件的多个chunk在一张卡片内显示
- **修改范围**：`output-stream.tsx`组件逻辑
- **技术方案**：
  1. 在组件层面对Message进行分组
  2. 修改渲染逻辑，支持事件卡片
  3. 实现流式内容更新

### 阶段3：统一事件处理逻辑
- **目标**：避免workspace页面和store重复处理
- **修改范围**：`workspace/page.tsx`和`unified-store.ts`
- **技术方案**：
  1. 将事件处理逻辑集中到store
  2. workspace页面只负责UI状态管理
  3. 统一消息创建逻辑

### 阶段4：优化数据模型（可选）
- **目标**：从根本上支持事件分组
- **修改范围**：Message类型定义和相关接口
- **技术方案**：
  1. 扩展Message接口支持事件概念
  2. 修改store的消息管理逻辑
  3. 更新相关组件适配新模型

## 🚨 风险控制

### 向后兼容性
- 保持现有Message接口不变
- 新功能通过扩展实现
- 渐进式迁移，避免破坏性变更

### 性能考虑
- 事件分组在组件层面进行，避免影响store性能
- 使用useMemo缓存分组结果
- 限制同时显示的事件数量

### 测试策略
- 每个阶段完成后进行功能测试
- 确保现有功能不受影响
- 重点测试流式显示和时序准确性

## 📊 技术决策记录

### 选择方案1的理由
1. **最小侵入性**：在组件层面处理分组，不影响底层数据模型
2. **快速实现**：可以立即开始修复，无需大规模重构
3. **风险可控**：每个阶段都可以独立测试和验证

### 关键技术点
1. **事件ID生成**：基于事件类型、时间戳和上下文生成唯一ID
2. **chunk合并策略**：按chunk_id和sequence合并message_chunk
3. **时间排序**：使用ISO时间戳进行准确排序
4. **流式更新**：支持事件内容的实时更新

## 🎯 预期效果

### 用户体验改进
1. **流畅滚动**：解决重复刷新问题
2. **清晰分组**：相关内容在同一卡片显示
3. **准确时序**：事件按真实时间顺序排列
4. **流式体验**：实时看到内容生成过程

### 技术架构改进
1. **职责清晰**：事件处理逻辑统一管理
2. **性能优化**：减少重复处理和渲染
3. **可维护性**：代码结构更清晰
4. **扩展性**：支持未来新的事件类型

---

## 🎯 实施进度

### ✅ 阶段1：修复OutputStream滚动和排序问题（已完成）

#### 修复内容
1. **滚动重复触发问题**：
   - **原因**：useEffect依赖messages数组，每次数组引用变化都触发滚动
   - **解决**：改为依赖messagesLength，只在消息数量变化时滚动
   - **优化**：使用requestAnimationFrame确保DOM更新后再滚动

2. **时间排序不准确问题**：
   - **原因**：使用字符串localeCompare比较时间戳，不同格式排序错误
   - **解决**：解析为Date对象进行真实时间比较
   - **Fallback策略**：有效时间戳优先，最后fallback到ID字符串排序

#### 技术改进
```typescript
// 滚动优化
const messagesLength = messages?.length || 0;
useEffect(() => {
  if (autoScroll && scrollAreaRef.current && messagesLength > 0) {
    requestAnimationFrame(() => {
      scrollContainer.scrollTop = scrollContainer.scrollHeight;
    });
  }
}, [messagesLength, autoScroll]); // 依赖长度而非数组

// 时间排序优化
const dateA = new Date(timeA);
const dateB = new Date(timeB);
if (dateA && dateB) {
  return dateA.getTime() - dateB.getTime(); // 真实时间比较
}
```

#### 验证结果
- ✅ TypeScript类型检查通过
- ✅ 滚动逻辑优化，避免重复触发
- ✅ 时间排序准确，支持多种时间戳格式

**下一步**：开始阶段2的实施，实现事件分组显示。

### ✅ 阶段2：实现消息块合并逻辑（已完成）

#### 技术事实确认
通过分析后端代码`src/server/research_stream_api.py`，确认了MessageChunk的分组逻辑：

**后端生成逻辑**：
```python
chunk_event = MessageChunkEvent(
    chunk_id=str(uuid.uuid4()),      # 每个chunk的唯一UUID（不用于分组）
    execution_id=execution_id,       # 🔥 执行级别标识（用于分组）
    agent_name=node_name,           # 🔥 代理名称（用于分组）
    chunk_type=self._determine_chunk_type(...),  # 🔥 chunk类型（用于分组）
    sequence=len(messages),         # 🔥 序列号（用于排序）
    is_final=False,                 # 🔥 结束标记
    # ...
)
```

**分组策略**：
- **分组键**：`execution_id + agent_name + chunk_type`
- **排序依据**：`sequence`字段
- **结束标记**：`is_final: true`

#### 实施内容

1. **创建mergeMessageChunk方法**（unified-store.ts）：
   - 基于`execution_id + agent_name + chunk_type`生成唯一messageId
   - 查找现有消息或创建新消息
   - 按sequence排序合并content chunks
   - 根据is_final更新isStreaming状态

2. **修改workspace页面事件处理**（workspace/page.tsx）：
   - 将onMessageChunk从`addMessage`改为`mergeMessageChunk`
   - 传递完整的chunk数据结构

#### 技术改进
```typescript
// 旧逻辑：每个chunk创建独立Message
const message = { id: data.chunk_id, content: data.content, ... };
useUnifiedStore.getState().addMessage(currentThreadId, message);

// 新逻辑：智能合并chunk到同一Message
useUnifiedStore.getState().mergeMessageChunk(currentThreadId, {
  execution_id: data.execution_id,
  agent_name: data.agent_name,
  chunk_type: data.chunk_type,
  // ...
});
```

#### 预期效果
- ✅ 同一执行的多个chunk合并为单一消息
- ✅ 流式内容实时更新，避免数百个独立卡片
- ✅ 保持现有展示组件兼容性
- ✅ 支持按sequence正确排序内容

### ✅ 阶段2.1：优化事件数据合并逻辑（已完成）

#### 问题发现
用户指出当前实现只是简单合并content，但没有处理chunk对应的其他事件数据，类似merge-message.ts的合并逻辑需求。

#### 后端事件数据结构
```python
metadata={
    "urls": extracted["urls"],           # 需要去重合并
    "images": extracted["images"],       # 需要去重合并  
    "token_info": token_info,           # 需要累积
    "node": current_node,               # 节点信息
}
```

#### 优化实施
实现了类似merge-message.ts的事件合并逻辑：

1. **URLs合并**：去重合并所有chunks中提取的URLs
2. **Images合并**：去重合并所有chunks中的图片链接  
3. **Token累积**：累加所有chunks的token消耗和成本
4. **Resources生成**：基于合并后的URLs自动生成Message.resources
5. **Metadata智能合并**：保留完整的聚合数据

#### 技术改进
```typescript
// 🔥 事件数据合并逻辑
const mergedUrls = new Set<string>();
const mergedImages = new Set<string>();
let totalTokens = { input: 0, output: 0 };

allChunks.forEach((chunk: any) => {
  const meta = chunk.metadata || {};
  // 合并URLs和Images
  if (meta.urls) meta.urls.forEach((url: string) => mergedUrls.add(url));
  if (meta.images) meta.images.forEach((img: string) => mergedImages.add(img));
  // 累积Token信息
  if (meta.token_info) {
    totalTokens.input += meta.token_info.input_tokens || 0;
    totalTokens.output += meta.token_info.output_tokens || 0;
  }
});

// 🔥 更新Message.resources
existingMessage.resources = Array.from(mergedUrls).map(url => ({
  uri: url,
  title: url,
}));
```

#### 效果提升
- ✅ 完整的事件数据合并，不仅仅是content
- ✅ 自动去重URLs和图片资源
- ✅ 准确累积token消耗统计
- ✅ 智能生成Message.resources供展示组件使用
- ✅ 保持与merge-message.ts类似的合并逻辑一致性

**下一步**：测试完整的事件合并效果，验证资源和token统计准确性。 